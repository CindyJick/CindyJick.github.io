<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer——字符串的排列</title>
      <link href="/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 假设 str = “abad” ，将 b 、c 、d 三个字符分别与第 index ( index 初始为0)位字符进行交换，把结果存入到 result 中；<br>2). 然后在上面可能的基础上，将第 index 位字符分别与它们后面的字符进行交换，把结果存入 result 中，不断递归；<br>3). 注意存入 result 过程中使用插入排序并过滤掉重复；  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(stratum(str.length()));</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            recursion(str.toCharArray(), <span class="number">0</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归求解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSeq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">char</span>[] charSeq, <span class="keyword">int</span> index, ArrayList&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (charSeq == <span class="keyword">null</span> || index &lt; <span class="number">0</span> || charSeq.length &lt;= index) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insert(charSeq, result);</span><br><span class="line">        recursion(charSeq, index + <span class="number">1</span>, result);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; charSeq.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charSeq[index] != charSeq[i]) &#123;</span><br><span class="line">                swap(charSeq, index, i);</span><br><span class="line">                insert(charSeq, result);</span><br><span class="line">                recursion(charSeq, index + <span class="number">1</span>, result);</span><br><span class="line">                swap(charSeq, i, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换两个字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSeq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] charSeq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (charSeq == <span class="keyword">null</span> || charSeq.length &lt;= ((i &gt; j) ? i : j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        ch = charSeq[i];</span><br><span class="line">        charSeq[i] = charSeq[j];</span><br><span class="line">        charSeq[j] = ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n的阶层，用来初始化ArrayList的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stratum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * stratum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将结果插入到result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSeq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] charSeq, ArrayList&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        String temp = <span class="keyword">new</span> String(charSeq);</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; result.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.compareTo(result.get(j)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除重复</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= result.size() || temp.compareTo(result.get(j)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(j, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 将字符串先按字典序进行升序排序，将其存入到 result 中；<br>2). 通过<strong>字典序算法</strong>找比当前字符串字典序大的字符串序列：<br>&emsp;a. 从字符串末尾往前检索，找到<strong>第一个非递增的字符</strong>，索引为 i<br>&emsp;b. 然后从 i + 1 往尾部检索，找到<strong>最后一个比 i 对应的字符大</strong>的字符，索引为 j<br>&emsp;c. 将 i 和 j 所在的字符进行<strong>交换</strong><br>&emsp;d. 将 i + 1 到 字符串末尾的区间的所有字符进行<strong>反序</strong><br>3).循环调用字典序算法，并把每一次的结果存到 result 的尾部，直到找到当前字符串字典序最大的串；  </p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li>用 “6798” 类比 “abdc”</li><li>要求出 “6798” 字符串按字典序排序的下一个字符串: “6879”</li><li>因为 “6798” 中的 “98” 的顺序已经是降序排列了，这说明 “8”、”9” 这两个字符已经不能再通过调整顺序来得出字典序更大的组合，意味着必须要引入新的元素</li><li>因此从 “9” 的前面一位字符作为新加入的元素 =&gt; “7”、”9”、”8” ，由于 “7” 已经作为过头部，因此从 “9”、”8” 中取比 “7” 要大的最小的一位作为头部，而 “98” 又是降序排列，故从 “7” 往后开始检索，找到的最后一个比 “7” 大的元素是 “8”</li><li>“7”、”8” 交换位置 =&gt; “6897” 发现还存在问题，交换了 “8” 之后，在它后面的元素的大小顺序应该是升序的(就像10进制加法进位一样，十位进了1，个位的就要重新归0)，而原本是降序的，因此将 “8” 后的字母倒序 =&gt;最终得到 “6879” 即为 “6798” 的下一个字典序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将str字符串按照字典序升序进行排列</span></span><br><span class="line">        <span class="keyword">char</span>[] orderedStr = str.toCharArray();</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(stratum(str.length()));</span><br><span class="line">        Arrays.sort(orderedStr);</span><br><span class="line">        result.add(<span class="keyword">new</span> String(orderedStr));</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">        <span class="keyword">int</span> i, j, len = orderedStr.length;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 从字符串末尾往前检索，找到第一个非递增的字符索引 i</span></span><br><span class="line">            <span class="keyword">for</span> (i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span> &amp;&amp; orderedStr[i] &gt;= orderedStr[i + <span class="number">1</span>]; --i) ;</span><br><span class="line">            <span class="comment">// 如果 i &lt; 0 则结束，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后从 i + 1 往尾部检索，找到最后一个比 i 对应的字符大的字符索引 j</span></span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len &amp;&amp; orderedStr[j] &gt; orderedStr[i]; ++j) ;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="comment">// 将 i 和 j 所在的字符进行交换</span></span><br><span class="line">            swap(orderedStr, i, j);</span><br><span class="line">            <span class="comment">// 将 i + 1 到 字符串末尾的区间的所有字符进行反序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (len - i - <span class="number">1</span>) / <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                swap(orderedStr, i + <span class="number">1</span> + k, len - <span class="number">1</span> - k);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(orderedStr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换两个字符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charSeq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] charSeq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (charSeq == <span class="keyword">null</span> || charSeq.length &lt;= ((i &gt; j) ? i : j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        ch = charSeq[i];</span><br><span class="line">        charSeq[i] = charSeq[j];</span><br><span class="line">        charSeq[j] = ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n的阶层，用来初始化ArrayList的大小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stratum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * stratum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二叉搜索树与双向链表</title>
      <link href="/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 </p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 中序遍历二叉搜索树的每一个结点<br>2). 在对左、右子树递归完后，该结点的<strong>左孩子指向</strong>改为<strong>原左孩子的最右孩子</strong>，该结点的<strong>右孩子指向</strong>改为<strong>原右孩子的最左孩子</strong><br>3). 最后，返回最左边的结点作为新链的头结点  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        inorder(pRootOfTree);</span><br><span class="line">        TreeNode head,p;</span><br><span class="line">        head = pRootOfTree;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inorder(root.left);</span><br><span class="line">            TreeNode left = root.left, right = root.right;</span><br><span class="line">            TreeNode p = left;</span><br><span class="line">            <span class="comment">// 将左子树的最右边作为根节点的左子树</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p = left;</span><br><span class="line">                    left = left.right;</span><br><span class="line">                &#125;</span><br><span class="line">                p.right = root;</span><br><span class="line">                root.left = p;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder(root.right);</span><br><span class="line">            <span class="comment">// 将右子树的最左边作为根节点的右子树</span></span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = right;</span><br><span class="line">                <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p = right;</span><br><span class="line">                    right = right.left;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = root;</span><br><span class="line">                root.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 用pre来记录中序遍历的<strong>前一个被遍历的根结点</strong>，用head来记录二叉搜索树<strong>最左边的结点</strong><br>2). 由于二叉搜索树的特性，pre一定比当前结点小 =&gt; $root-&gt;left = pre, pre-&gt;right = root$<br>3). 当pre为空时，且遍历到最左子树的尾部时，$head = root$  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(root.left);</span><br><span class="line">        <span class="comment">// 由于二叉搜索树的特性，前一个结点一定比现在结点的值要小</span></span><br><span class="line">        root.left = pre;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        Convert(root.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——复杂链表的复制</title>
      <link href="/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/09/17/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）  </p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 复制next主干好办，难做的是<strong>复制random的指向</strong><br>2). 我们只知道<strong>旧链中random指向的结点</strong>，但是不知道其<strong>对应的新链的结点</strong><br>3). 因此可以将<strong>旧链结点与新链结点的对应关系</strong>存储在HashMap中作为配对表<br>4). 在第一遍复制next主干时顺便将对应关系存好<br>5). 在第二遍复制random指向时，只要将<strong>旧的random指向作为键</strong>从对应表中查找就能找到<strong>新链对应的结点</strong>作为新的random指向  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode p,head,node,temp;</span><br><span class="line">        p = pHead;</span><br><span class="line">        head = <span class="keyword">new</span> RandomListNode(-<span class="number">1</span>);</span><br><span class="line">        node = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新旧结点匹配表</span></span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; mapTable = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 复制next主干</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            node.next = temp;</span><br><span class="line">            node = node.next;</span><br><span class="line">            mapTable.put(p, temp);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制random指向</span></span><br><span class="line">        p = pHead;</span><br><span class="line">        node = head.next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.random = mapTable.get(p.random);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 遍历next主干，复制新结点插入到旧结点的后面<br>2). 再遍历一次next主干，让每一<strong>新结点的random指向</strong>其前一个<strong>旧结点的random指向</strong>结点的<strong>下一个</strong>结点<br>3). 最后再遍历一次next主干，拆分出新链  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、复制每个节点，如：复制节点A得到A1，将A1插入节点A后面</span></span><br><span class="line"><span class="comment">        2、遍历链表，A1-&gt;random = A-&gt;random-&gt;next;</span></span><br><span class="line"><span class="comment">        3、将链表拆分成原链表和复制后的链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     </span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode *currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode)&#123;</span><br><span class="line">            RandomListNode *node = <span class="keyword">new</span> RandomListNode(currNode-&gt;label);</span><br><span class="line">            node-&gt;next = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next = node;</span><br><span class="line">            currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode)&#123;</span><br><span class="line">            RandomListNode *node = currNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(currNode-&gt;random)&#123;               </span><br><span class="line">                node-&gt;random = currNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        RandomListNode *pCloneHead = pHead-&gt;next;</span><br><span class="line">        RandomListNode *tmp;</span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode-&gt;next)&#123;</span><br><span class="line">            tmp = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next =tmp-&gt;next;</span><br><span class="line">            currNode = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二叉树中和为某一值的路径</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)  </p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 可以用深度优先搜索的思路，用递归去写，找到路径的条件是$sum = target$且为<strong>叶子结点</strong><br>2). 粗糙的剪枝减少无用的遍历，满足$sum &lt; target$才可以往<strong>非空子树</strong>方向递归<br><strong>注：后面发现代码有疏漏，没有考虑路径长的放list前面的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>, target, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; path,<span class="keyword">int</span> sum,<span class="keyword">int</span> target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="keyword">if</span> (sum == target &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            path.add(root.val);</span><br><span class="line">            result.add(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">            path.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dfs(root.left, (ArrayList&lt;Integer&gt;) path.clone(), sum, target, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dfs(root.right, (ArrayList&lt;Integer&gt;) path.clone(), sum, target, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 考虑了路径长度的问题，插入时找对位置插入<br>2). 每走一步克隆一份新路径 =&gt; 使用同一条path + 回退   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, target, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> target, ArrayList&lt;Integer&gt; path, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        target -= root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (path.size() &gt;= result.get(i).size()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dfs(root.left, target, path, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dfs(root.right, target, path, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二叉搜索树的后序遍历</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。  </p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 首先确定二叉搜索树的要求——<strong>任意结点的值</strong>必定<strong>大于</strong>其<strong>左子树</strong>的任意结点的值且<strong>小于</strong>其<strong>右子树</strong>的任意结点的值<br>2). 接着确定后序遍历的特点——最后一个字符必为其<strong>根节点</strong><br>3). 因此我们可以根据以上的特性，将后序遍历字符串分割为<strong>左子树、右子树和根节点</strong>三个部分<br>4). 在确保其左右子树符合二叉搜索树的规则时，将<strong>左、右子树分别递归代入函数</strong>中进行判断，且取其<strong>相与</strong>的结果  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sequence.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[sequence.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">boolean</span> left, right;</span><br><span class="line">        <span class="keyword">for</span> (i = sequence.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root &gt; sequence[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (root &lt;= sequence[j]) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left = (i &lt; <span class="number">0</span>) || VerifySquenceOfBST(Arrays.copyOfRange(sequence, <span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">        right = (i + <span class="number">1</span> &gt; sequence.length - <span class="number">2</span>) || VerifySquenceOfBST(Arrays.copyOfRange(sequence, i + <span class="number">1</span>, sequence.length - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>参考思路与初始思路类似，通过元素下标替代了拷贝数组的过程，代码更简洁   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = r;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; l &amp;&amp; a[i - <span class="number">1</span>] &gt; a[r]) --i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= l; --j) <span class="keyword">if</span>(a[j] &gt; a[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(a, l, i - <span class="number">1</span>) &amp;&amp; (judge(a, i, r - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(a, <span class="number">0</span>, a.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——从上往下打印二叉树</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). <strong>广度优先搜索</strong>的思路，用一个ArrayList来模拟<strong>队列</strong>，另一个ArrayList来存储结果<br>2). 只要队列中还有元素，则将其弹出，将弹出元素保存到结果，并将其<strong>非空</strong>的<strong>左、右</strong>结点入队列，直到队列为空    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ArrayList&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            p = queue.remove(<span class="number">0</span>);</span><br><span class="line">            result.add(p.val);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>参考思路与初始思路类似，此处不做叙述   </p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——栈的压入、弹出序列</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 用一个ArrayList来模拟栈，用两个指针<strong>i</strong>、<strong>j</strong>来分别指向<strong>下一个要压入栈的元素</strong>、<strong>下一个要弹出栈的元素</strong><br>2). 对于每一个<strong>j</strong>指向的元素，都要找到与之匹配的栈顶元素<br>3). 如果没有找到，则将<strong>i所指向的元素入栈</strong>，i自增，直到越界<br>4). 如果找到，则将<strong>栈顶元素出栈</strong>，j自增，继续匹配  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA,<span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;(pushA.length);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || stack.get(<span class="number">0</span>) != popA[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= pushA.length) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.add(<span class="number">0</span>,pushA[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.remove(<span class="number">0</span>);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= popA.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>参考思路与初始思路类似，写法不一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA,<span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;(pushA.length);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            stack.add(<span class="number">0</span>, pushA[i]);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; popA.length &amp;&amp; stack.get(<span class="number">0</span>) == popA[j]) &#123;</span><br><span class="line">                stack.remove(<span class="number">0</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= popA.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——包含min函数的栈</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 设置一个stack变量作为栈，一个ArrayList变量来栈中元素排序后的结果<br>2). 每次push的时候，除了要将元素插入push到stack中，还要都将新元素使用插入排序的方法插入到ArrayList中<br>3). 每次pop的时候，除了在stack中pop掉以外，还要从ArrayList中remove掉<br>4). 获取min的时候，只要获取ArrayList的第一个元素就可以了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node &lt; list.get(i)) &#123;</span><br><span class="line">                list.add(i, node);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.remove(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() &gt; <span class="number">0</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p> 1). 使用两个栈，其中一个作为<strong>正常栈</strong>来使用，另一个作为<strong>存更小值的栈</strong>来使用<br> 2). 当push时，第二个栈只有<strong>为空</strong>时或者<strong>新元素小于等于其栈顶元素</strong>时才将元素进栈<br> 3). 当pop时，第二个栈只有<strong>不为空</strong>且<strong>栈顶元素与第一个栈的栈顶元素相等</strong>才将元素出栈<br>4). min操作就是返回第二个栈的栈顶元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty() || minStack.peek() &gt;= node) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!minStack.empty() &amp;&amp; minStack.peek().equals(stack.peek())) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.empty() ? -<span class="number">1</span> : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一些跟牛逼的是用数组做，然后自己写扩容方法，此处贴出链接<br><a href="https://www.nowcoder.com/profile/2800145/codeBookDetail?submissionId=20534256" target="_blank" rel="noopener">真·栈</a>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/*借用辅助栈存储min的大小，自定义了栈结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer[] elements = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">        elements[size++] = node;</span><br><span class="line">        <span class="keyword">if</span>(node &lt;= min)&#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            min = minStack.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(min);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//    System.out.println(min+"");</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span>(size &gt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> newLen = (len*<span class="number">3</span>)/<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//每次扩容方式</span></span><br><span class="line">            elements = Arrays.copyOf(elements, newLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer top = top();</span><br><span class="line">        <span class="keyword">if</span>(top != null)&#123;</span><br><span class="line">            elements[size<span class="number">-1</span>] = (Integer) null;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        minStack.pop();    </span><br><span class="line">        min = minStack.peek();</span><br><span class="line">    <span class="comment">//    System.out.println(min+"");</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(size<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> elements[size<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Integer) null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——顺时针打印矩阵</title>
      <link href="/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/09/11/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 最外层包一个循环，循环次数为矩阵的大小——因为实际上还是要遍历每一个点<br>2). 设置i，j的<strong>步长 addI，addJ</strong><br>3). 设置i，j与原本矩阵界限的<strong>边距 paddingI,paddingJ</strong><br>4). 然后每走一步都对下一步是否会越界进行四个方向的判断——如果越界则说明<strong>需要转向</strong><br>5). 需要注意的是，由<strong>向左转为向上</strong>时需要增大<strong>paddingI</strong> ，由<strong>向上转为向右</strong>时需要增大<strong>paddingJ</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i, j, addI, addJ, paddingI = <span class="number">0</span>, paddingJ = <span class="number">0</span>, k, len = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>, addI = <span class="number">0</span>, addJ = <span class="number">1</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            result.add(matrix[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j + addJ &gt;= matrix[<span class="number">0</span>].length - paddingJ) &#123;</span><br><span class="line">                <span class="comment">// 右转下</span></span><br><span class="line">                addI = <span class="number">1</span>;</span><br><span class="line">                addJ = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + addI &gt;= matrix.length - paddingI) &#123;</span><br><span class="line">                <span class="comment">// 下转左</span></span><br><span class="line">                addI = <span class="number">0</span>;</span><br><span class="line">                addJ = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j + addJ &lt; paddingJ) &#123;</span><br><span class="line">                <span class="comment">// 左转上</span></span><br><span class="line">                addI = -<span class="number">1</span>;</span><br><span class="line">                addJ = <span class="number">0</span>;</span><br><span class="line">                paddingI++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + addI &lt; paddingI) &#123;</span><br><span class="line">                <span class="comment">// 上转右</span></span><br><span class="line">                addI = <span class="number">0</span>;</span><br><span class="line">                addJ = <span class="number">1</span>;</span><br><span class="line">                paddingJ++;</span><br><span class="line">            &#125;</span><br><span class="line">            i += addI;</span><br><span class="line">            j += addJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p> 1). 最外包一层循环，遍历次数为矩阵的<strong>圈数</strong><br> 2). 在里面时四个并列的循环，分别对应四个方向打印元素  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*解题思路：顺时针打印就是按圈数循环打印，一圈包含两行或者两列，在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        res.clear();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> collor=matrix[<span class="number">0</span>].size();<span class="comment">//列数</span></span><br><span class="line">        <span class="comment">//计算打印的圈数</span></span><br><span class="line">        <span class="keyword">int</span> circle=((row&lt;collor?row:collor)<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//圈数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circle;i++)&#123;</span><br><span class="line">            <span class="comment">//从左向右打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;collor-i;j++)</span><br><span class="line">                res.push_back(matrix[i][j]);         </span><br><span class="line">            <span class="comment">//从上往下的每一列数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;row-i;k++)</span><br><span class="line">                res.push_back(matrix[k][collor<span class="number">-1</span>-i]);</span><br><span class="line">            <span class="comment">//判断是否会重复打印(从右向左的每行数据)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=collor-i<span class="number">-2</span>;(m&gt;=i)&amp;&amp;(row-i<span class="number">-1</span>!=i);m--)</span><br><span class="line">                res.push_back(matrix[row-i<span class="number">-1</span>][m]);</span><br><span class="line">            <span class="comment">//判断是否会重复打印(从下往上的每一列数据)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=row-i<span class="number">-2</span>;(n&gt;i)&amp;&amp;(collor-i<span class="number">-1</span>!=i);n--)</span><br><span class="line">                res.push_back(matrix[n][i]);&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔兽争霸地图装载卡住问题</title>
      <link href="/2019/09/10/%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B8%E5%9C%B0%E5%9B%BE%E8%A3%85%E8%BD%BD%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/10/%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B8%E5%9C%B0%E5%9B%BE%E8%A3%85%E8%BD%BD%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一-问题"><a href="#一-问题" class="headerlink" title="一. 问题"></a>一. 问题</h3><p><a href="https://tieba.baidu.com/p/5481674224?red_tag=1976587729" target="_blank" rel="noopener">图片来源，侵删 https://tieba.baidu.com/p/5481674224?red_tag=1976587729</a></p><p>在魔兽官方对战平台上玩《镇魂将》、《我不会武功》地图的时候，出现要不就是闪退、要不就是一直卡在装载中，真是让我眼泪掉下来；  </p><h3 id="二-解决思路"><a href="#二-解决思路" class="headerlink" title="二. 解决思路"></a>二. 解决思路</h3><h4 id="1-根据装载进度判断问题"><a href="#1-根据装载进度判断问题" class="headerlink" title="1. 根据装载进度判断问题"></a>1. 根据装载进度判断问题</h4><img src="/2019/09/10/魔兽争霸地图装载卡住问题/pasted-0.png" title="魔兽争霸装载地图卡住">  <h4 id="2-在魔兽平台进行游戏设置"><a href="#2-在魔兽平台进行游戏设置" class="headerlink" title="2. 在魔兽平台进行游戏设置"></a>2. 在魔兽平台进行游戏设置</h4><p>1). 在“游戏路径”中重新设置对应的魔兽版本<br>2). 在“游戏设置”中选择开启“openGL模式”<br>3). 重新运行游戏即可  </p><hr>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔兽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二叉树的镜像</title>
      <link href="/2019/09/09/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2019/09/09/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述：<br><img src="/2019/09/09/剑指offer——二叉树的镜像/pasted-0.png" title="输入描述">  </p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>递归先序遍历树，每次访问根节点的时候就将左右子树进行交换  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = temp;</span><br><span class="line">            Mirror(root.left);</span><br><span class="line">            Mirror(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>非递归写法(特别是后序遍历的非递归写法)，还在摸索中  </p><p>```</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——树的子结构</title>
      <link href="/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 只想到了最差的思路——先序遍历<strong>待匹配串root1</strong>，对里面的<strong>每一个结点</strong>都进行一次递归匹配<strong>匹配串root2</strong><br>2). 递归的思路是，如果参数结点任一个为空，则说明不匹配<br>3). 如果两个参数结点的值相同，则将其左、右结点继续放入递归中<br>4). 否则表明该递归匹配失败  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> recursion(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span> || root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left = <span class="keyword">true</span>,right = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1.val == root2.val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root2.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                left = recursion(root1.left, root2.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root2.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = recursion(root1.right, root2.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>与初始思路雷同，此处不做叙述  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRootA, TreeNode* pRootB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootB == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRootA == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRootB-&gt;val == pRootA-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(pRootA-&gt;left, pRootB-&gt;left)</span><br><span class="line">                &amp;&amp; isSubtree(pRootA-&gt;right, pRootB-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRootA, TreeNode* pRootB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootA == <span class="literal">NULL</span> || pRootB == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(pRootA, pRootB) ||</span><br><span class="line">            HasSubtree(pRootA-&gt;left, pRootB) ||</span><br><span class="line">            HasSubtree(pRootA-&gt;right, pRootB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——合并两个排序的链表</title>
      <link href="/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 新建一个空的头结点<br>2). 设置三个指针，p1、p2分别用来遍历链表1、2，而p3用来表示新链的最后一个结点<br>3). 比较p2、p1所指结点的大小，将小的一个接到p3后面，然后对应的指针往后挪一位，直到p2、p1任意一个为空<br>4). 由于链表1、2的长度不一定相等，因此需要把剩余的结点都接到p3后面<br>5). 返回空头结点的下一个结点作为结果  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode p1, p2, p3 = <span class="keyword">null</span>, rHead,temp;</span><br><span class="line">        p1 = list1;</span><br><span class="line">        p2 = list2;</span><br><span class="line">        rHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        p3 = rHead;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class="line">                p3.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p3.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p3.next = p1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p3.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>递归写法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">           list1.next = Merge(list1.next, list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           list2.next = Merge(list1, list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——反转链表</title>
      <link href="/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个链表，反转链表后，输出新链表的表头。</p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 新建一个空的头结点<br>2). 遍历链表，遍历一个结点，就将该结点插入到<strong>新的头结点的后面</strong><br>3). 返回<strong>新头结点的下一个结点</strong>作为反转链表的头结点  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode nHead,nP = <span class="keyword">null</span>,p,temp;</span><br><span class="line">        nHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = p.next;</span><br><span class="line">            nP = nHead.next;</span><br><span class="line">            nHead.next = p;</span><br><span class="line">            p.next = nP;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 采用递归的思路，先递归到链表的最后面<br>2). 然后反转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/75e878df47f24fdc9dc3e400ec6058ca</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">            val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空或者链表中只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>||pHead-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//先反转后面的链表，走到链表的末端结点</span></span><br><span class="line">        ListNode* pReverseNode=ReverseList(pHead-&gt;next);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//再将当前节点设置为后面节点的后续节点</span></span><br><span class="line">        pHead-&gt;next-&gt;next=pHead;</span><br><span class="line">        pHead-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> pReverseNode;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——链表中倒数第k个结点</title>
      <link href="/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个链表，输出该链表中倒数第k个结点。</p><p>数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 用一个ArrayList（或者栈）将之前遍历过的k个结点都存起来<br>2). 判断k有没有超限，符合则返回list中第k-1的结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ListNode&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(<span class="number">0</span>, p);</span><br><span class="line">            <span class="keyword">if</span> (stack.size() &gt; k) &#123;</span><br><span class="line">                stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (k &gt; <span class="number">0</span>) &amp;&amp; (k &lt;= stack.size()) ? stack.get(k - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 设置两个指针，一个用来遍历链表，第二个用来指向第一个指针的第前k-1个结点<br>2). 用i来计数，只有当i &gt;= k时，第二个指针才开始挪动  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p = head,targetNode = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i++ &gt;= k) &#123;</span><br><span class="line">                targetNode = targetNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &lt;= i ? targetNode : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——调整数组顺序使奇数位于偶数前面</title>
      <link href="/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/09/06/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 从头到尾遍历数组<br>2). 如果遇到奇数，那么将（上一个奇数，当前奇数）的值都往后挪动一位<br>3). 挪动完成后，将当前奇数拷贝到上一个奇数的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                temp = array[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= index; --j) &#123;</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                &#125;</span><br><span class="line">                array[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>还有可以通过空间换时间的方式来做，new一个新数组，将奇数拷贝到前面，将偶数拷贝到后面，此处不贴出代码</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——数值的整数次方</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 如果直接循环乘的话，当指数很大的时候，乘的次数会很多，从而有可能超出时间限制<br>2). 假设指数为15时，指数可以拆分为 $8+4+2+1$ =&gt; 表示只要将$x^{2^3}{\cdot}x^{2^2}{\cdot}x^{2^1}{\cdot}x^{2^0}$连乘起来就好了  </p><script type="math/tex; mode=display">\begin{eqnarray*}x^{15} &=& x^{1111} \\&=& x^{2^3}{\cdot}x^{2^2}{\cdot}x^{2^1}{\cdot}x^{2^0} \\&=& x^{8}{\cdot}x^{4}{\cdot}x^{2}{\cdot}x^{1} \\\end{eqnarray*}</script><p>3). 又因为它们之间存在次方关系，因此通过将指数右移，用num来记录$x^{2^k}$值，当每次指数最低位为1时将num值乘上result  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> abs = exponent &gt; <span class="number">0</span> ? exponent : -exponent;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>,num = base;</span><br><span class="line">        <span class="keyword">while</span> (abs != <span class="number">0</span>) &#123;</span><br><span class="line">            result *= (abs &amp; <span class="number">1</span>) == <span class="number">1</span> ? num : <span class="number">1</span>;</span><br><span class="line">            num *= num;</span><br><span class="line">            abs = abs &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &gt; <span class="number">0</span> ? result : (<span class="number">1</span> / result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>与初始思路雷同，此处不加叙述</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二进制中的个数</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>由于int的负数在计算机中本来就是用补码表示，因此这道题目只用简单地右移取最后一位就可以了(值得注意的是右移要使用<strong>无符号右移</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>思路同样也是循环数1的个数，但是精妙的地方在于不需要左右移来获取下一位数，而是通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` JAVA</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            sum ++;</span><br><span class="line">            n = n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——矩形覆盖</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>将横着放想象成跳台阶中的跳一级台阶，将竖着放想象成跳两级台阶 =&gt; 等同于跳台阶问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&lt;=<span class="number">0</span>?<span class="number">0</span>:target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preNum = <span class="number">2</span>,pPreNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;++i)&#123;</span><br><span class="line">            preNum = preNum + pPreNum;</span><br><span class="line">            pPreNum = preNum - pPreNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>与初始思路雷同，此处不做叙述</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——变态跳台阶</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 根据题意我们发现n级台阶的第一步分为两种情况：①直接跳到终点②跳到距终点为k(k &lt; n)的台阶上，再从k级台阶开始跳<br>2). 因此我们不难得出公式：$ f(n) = \sum_{i = 1}^{n-1}{f(i)} + 1 $<br>3). 采用动态规划的思想，将每一项的结果保存到数组中，减少重复计算  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; record = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        record.add(<span class="number">0</span>);</span><br><span class="line">        record.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum  = <span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record.size() - <span class="number">1</span> &lt; i) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    temp += record.get(j);</span><br><span class="line">                    <span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123;</span><br><span class="line">                        temp++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                record.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += record.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i == target - <span class="number">1</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>将初始思路中的公式化简</p><script type="math/tex; mode=display">\begin{eqnarray*}{f(n)} &=& {f(n-1)} + {f(n-2)} + {\cdots} + {f(1)} + 1 \\{f(n)} &=& {f(n-1)} + {f(n-1)} \\{f(n)} &=& 2^1{\cdot}f(n-1) \\{f(n)} &=& 2^2{\cdot}f(n-2) \\&{\vdots}& \\{f(n)} &=& 2^{n-1} {\cdot}f(1) \\{f(n)} &=& 2^{n-1} \\\end{eqnarray*}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; target - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——跳台阶</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>跳台阶，可以采用递归去做，递归条件为没有剩余台阶时返回1种可能性，否则返回递归跳2级和跳1级的可能性的和；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            time += JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        time += JumpFloor(target - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 其实这个问题本质上也是一个斐波那契数列的问题，只不过是起始数值不一样；<br>2). n级台阶最后一步的可能情况为(n &gt; 2)：在(n - 1)台阶上跳一级 + 在(n - 2)台阶上跳两级<br>3). 得出结论：f(n) = f(n - 1) + f(n - 2) (n &gt; 2)<br>4). 由于递归可能在n比较大的情况下的导致递归树很大，因此采用迭代的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preNum = <span class="number">2</span>, pPreNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target &lt;= <span class="number">0</span> ? <span class="number">0</span> : target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;++i) &#123;</span><br><span class="line">            preNum += pPreNum;</span><br><span class="line">            pPreNum = preNum - pPreNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——斐波那契数列</title>
      <link href="/2019/09/04/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2019/09/04/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>斐波那契数列公式为 f(n) = f(n - 1) + f(n - 2) (n &gt;= 2)，因此可以用递归的方式实现。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n &lt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>由于当参数过大时使用递归可能会导致递归树过大，因此使用循环来处理这个问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preNum = <span class="number">0</span>, pPreNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            preNum += pPreNum;</span><br><span class="line">            pPreNum = preNum - pPreNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——旋转数组的最小值</title>
      <link href="/2019/09/04/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2019/09/04/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>只要循环遍历一遍数组必然能够找到最小值，这里选择了从后往前遍历<strong>(题目中的非递减其实包含了元素相等的情况)</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt; array[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>利用二分查找的思想，找出<strong>旋转后的数组</strong>，并取其<strong>第一个元素</strong><br>1). 取<strong>mid的值</strong>与<strong>right的值</strong>进行判断<br>2). 如果mid的值 &gt; right的值，则说明mid位于<strong>未旋转数组</strong>中，将left移至mid+1<br>3). 如果mid的值 &lt; right的值，则说明mid位于<strong>旋转数组</strong>中，将right移至mid<br>4). 否则mid的值 = right的值，这时只需将<strong>right往前移动一格</strong>即可<br>5). 最后取旋转后的数组的第一个元素  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[right])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——用两个栈实现队列</title>
      <link href="/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目链接</a></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). push直接将数push到第一个栈中<br>2). pop操作时先将第一个栈中的内容全部pop到第二个栈中<br>3). 第二个栈pop一个元素并保存到变量<br>4). 最后将第二个栈的内容全部pop到第一个栈中，返回变量作为结果  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack2.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). push直接将数push到第一个栈中<br>2). pop操作时先判断第二个栈是否为空<br>3). 第二个栈不为空则返回第二个栈pop的一个元素作为结果<br>4). 否则将第一个栈的内容全部pop到第二个栈中并返回第二个栈pop的一个元素作为结果  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——重建二叉树</title>
      <link href="/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目链接</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>二叉树结构:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 使用<strong>分治</strong>的思想，将大树分成小树解决<br>2). 取当前<strong>先序</strong>数组的<strong>第一</strong>个元素作为<strong>根节点</strong>并保存到新节点中<br>3). 然后在中序遍历中找到其位置，从而将中序数组分为左右两部分<br>4). 统计中序遍历左边部分的个数 =&gt; 得到<strong>左子树的节点个数</strong><br>5). 根据左子树节点个数将先序遍历数组也分为左右两部分<br>6). 将<strong>先序的左部</strong>和<strong>中序的左部</strong>作为参数进行递归作为新节点的左子树<br>7). 将<strong>先序的右部</strong>和<strong>中序的右部</strong>作为参数进行递归作为新节点的右子树<br>8). 递归结束条件为先序数组或中序数组长度为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(pre,in,<span class="number">0</span>,pre.length-<span class="number">1</span>,<span class="number">0</span>,in.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> sp,<span class="keyword">int</span> ep,<span class="keyword">int</span> si,<span class="keyword">int</span> ei)</span></span>&#123;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(sp &gt; ep || si &gt; ei)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p = <span class="keyword">new</span> TreeNode(pre[sp]);</span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            p.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> n = pre[sp];</span><br><span class="line">            <span class="keyword">int</span> iP = <span class="number">0</span>,iI = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( i = si ; i &lt; ei; ++i )&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[i] == n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lNum = i - si;</span><br><span class="line">            p.left = recursion(pre,in,sp + <span class="number">1</span>,sp + lNum,si,si + lNum);</span><br><span class="line">            p.right = recursion(pre,in,sp + lNum + <span class="number">1</span>,ep,i + <span class="number">1</span>,ei);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>与初始思路雷同，此处不做叙述<br><a href="https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6" target="_blank" rel="noopener">参考链接</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——从尾到头打印链表</title>
      <link href="/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目链接</a></p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>链表结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>遍历链表并将链表中每个结点的值插入到ArrayList的第一个位置——感觉这道题可能要在c语言中才能体现出它的想法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList(<span class="number">100</span>);</span><br><span class="line">        ListNode head = listNode, p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="number">0</span>,p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 利用栈先入后出的特性完成<br>2). 存下来然后进行数组翻转<br>3). 利用递归  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">栈思路：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">        ListNode *p=<span class="literal">NULL</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            stk.push(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            value.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">数组翻转：数组翻转可以用C++自带的函数，也可以自己实现</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">        ListNode *p=<span class="literal">NULL</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            value.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//reverse(value.begin(),value.end()); //C++自带的翻转函数</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=value.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            temp=value[i];    <span class="comment">//也可以用swap函数，swap(value[i],value[j]);</span></span><br><span class="line">            value[i]=value[j];</span><br><span class="line">            value[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">递归思路：</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode *p=<span class="literal">NULL</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                printListFromTailToHead(p-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            value.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——替换空格</title>
      <link href="/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二. 思路"></a>二. 思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>遍历一遍字符串的字符，如果不是空格则将该字符新增到新的str中，如果是空格则将”%20”增加到新的str中——无耻的用了StringBuffer，好像违背了题目的本意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(str.length()*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; str.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">' '</span> == (str.charAt(i)))&#123;</span><br><span class="line">                result.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 先循环一次计算出字符中的空格数<br>2). 然后从字符串的尾端开始遍历字符<br>3). 记录当前遇到的空格数<br>4). 对于非空格字符 =&gt; <strong>新位置 = 旧位置 + (3 - 1)*空格数</strong><br>5). 空格字符 =&gt; 用”%20”覆盖  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！</span></span><br><span class="line"><span class="comment">问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。</span></span><br><span class="line"><span class="comment">      从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下</span></span><br><span class="line"><span class="comment">      从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>; <span class="comment">//indexold为为替换前的str下标</span></span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + spacenum*<span class="number">2</span>;<span class="comment">//计算空格转换成%20之后的str长度</span></span><br><span class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;<span class="comment">//indexold为为把空格替换为%20后的str下标</span></span><br><span class="line">        str.setLength(newlength);<span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界</span></span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span> &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">' '</span>)&#123;  <span class="comment">//</span></span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'%'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer——二维数组中的查找</title>
      <link href="/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/09/03/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="一-题目"><a href="#一-题目" class="headerlink" title="一. 题目"></a>一. 题目</h3><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目链接</a></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="二-思路"><a href="#二-思路" class="headerlink" title="二.思路"></a>二.思路</h3><h4 id="1-初始思路"><a href="#1-初始思路" class="headerlink" title="1. 初始思路"></a>1. 初始思路</h4><p>1). 由于该二维数组的特性：右&gt;左，下&gt;上，因此从其从左上到右下的方向的元素是有序的，从左上到右下使用二分查找的方式选取一个点；<br>2). 分别对其所在行和所在列再次进行二分查找；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">0</span>,sj = <span class="number">0</span>,ei = array.length - <span class="number">1</span>,ej = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> mi,mj;</span><br><span class="line">        <span class="keyword">while</span>(si &lt;= ei &amp;&amp; sj &lt;= ej)&#123;</span><br><span class="line">            mi = si + (ei - si)/<span class="number">2</span>;</span><br><span class="line">            mj = sj + (ej - sj)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(FindSection(target,array,mi,mj,<span class="keyword">true</span>) || FindSection(target,array,mi,mj,<span class="keyword">false</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mi][mj] &gt; target)&#123;</span><br><span class="line">                ei = mi - <span class="number">1</span>;</span><br><span class="line">                ej = mj - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                si = mi + <span class="number">1</span>;</span><br><span class="line">                sj = mj + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">FindSection</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span>[][] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span> isLine)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si,sj,ei,ej,mi,mj;</span><br><span class="line">        <span class="keyword">if</span>(isLine)&#123;</span><br><span class="line">            si = i;</span><br><span class="line">            ei = i;</span><br><span class="line">            sj = <span class="number">0</span>;</span><br><span class="line">            ej = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            si = <span class="number">0</span>;</span><br><span class="line">            ei = i;</span><br><span class="line">            sj = j;</span><br><span class="line">            ej = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(si &lt;= ei &amp;&amp; sj &lt;= ej)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLine)&#123;</span><br><span class="line">                mj = sj + (ej - sj)/<span class="number">2</span>;</span><br><span class="line">                mi = si;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mi = si + (ei - si)/<span class="number">2</span>;</span><br><span class="line">                mj = sj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[mi][mj] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mi][mj] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isLine)&#123;</span><br><span class="line">                    ej = mj - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ei = mi - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(isLine)&#123;</span><br><span class="line">                    sj = mj + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    si = mi + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参考思路"><a href="#2-参考思路" class="headerlink" title="2. 参考思路"></a>2. 参考思路</h4><p>1). 从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。<br>2). target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i=rows-<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;cols)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;array[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[i][j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点与多边形</title>
      <link href="/2019/08/24/%E7%82%B9%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2/"/>
      <url>/2019/08/24/%E7%82%B9%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="判断一个点是否在多边形内部"><a href="#判断一个点是否在多边形内部" class="headerlink" title="判断一个点是否在多边形内部"></a>判断一个点是否在多边形内部</h2><p>转自参考链接 侵删 <a href="https://www.cnblogs.com/anningwang/p/7581545.html" target="_blank" rel="noopener">https://www.cnblogs.com/anningwang/p/7581545.html</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>阿里巴巴模拟笔试有一道编程题，大意为:已知在一个二维平面上，有一个坐标点和一个多边形，多边形的点已数组的方式按链接顺序存放，且第一个点与最后一个点相连。判断坐标点是否在多边形内部？如果在外部则给出距离多边形的最短距离？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1-射线法"><a href="#1-射线法" class="headerlink" title="1.射线法"></a>1.射线法</h4><ul><li>分别取多边形各顶点<strong>横、纵</strong>坐标的最大、最小值=&gt;用矩形将多边形框住(排除在框外的点)</li><li>假设<strong>待测点</strong>向右方延伸出一条<strong>射线</strong></li><li>计算多边形的每条边与这条射线的交点个数(注意特例)</li><li>根据交点个数的<strong>奇偶</strong>判断待测点与多边形的关系<img src="/2019/08/24/点与多边形/pasted-0.png" title="正常情况:点在多边形外"><img src="/2019/08/24/点与多边形/pasted-1.png" title="正常情况:点在多边形内"><img src="/2019/08/24/点与多边形/pasted-3.png" title="特殊情况:点在多边形上"><img src="/2019/08/24/点与多边形/pasted-4.png" title="特殊情况:多边形经过顶点"><img src="/2019/08/24/点与多边形/pasted-5.png" title="特殊情况:射线与边重叠"></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h3 id="1-射线法-1"><a href="#1-射线法-1" class="headerlink" title="1.射线法"></a>1.射线法</h3><ul><li>线段<strong>两端</strong>在<strong>射线</strong>的<strong>两侧</strong>=&gt;射线与线段<strong>相交</strong></li><li>约定射线经过的点在射线的<strong>上侧</strong></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-admin管理hexo文章</title>
      <link href="/2019/08/23/hexo-admin%E7%AE%A1%E7%90%86hexo%E6%96%87%E7%AB%A0/"/>
      <url>/2019/08/23/hexo-admin%E7%AE%A1%E7%90%86hexo%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装hexo-admin"><a href="#1-安装hexo-admin" class="headerlink" title="1.安装hexo-admin"></a>1.安装hexo-admin</h3><p>键入npm install —save hexo-admin</p><h3 id="2-重新启动hexo"><a href="#2-重新启动hexo" class="headerlink" title="2.重新启动hexo"></a>2.重新启动hexo</h3><p>键入hexo server -d</p><h3 id="3-访问admin页面"><a href="#3-访问admin页面" class="headerlink" title="3.访问admin页面"></a>3.访问admin页面</h3><p>在浏览器上访问 yourip:4000/admin</p><img src="/2019/08/23/hexo-admin管理hexo文章/pasted-0.png" title="example"><h3 id="4-设置amdin登陆拦截"><a href="#4-设置amdin登陆拦截" class="headerlink" title="4.设置amdin登陆拦截"></a>4.设置amdin登陆拦截</h3><ol><li>先在admin页面中点击”Settings”选项卡<img src="/2019/08/23/hexo-admin管理hexo文章/pasted-1.png" title="example"></li><li>接着点击”Setup authentification here”<img src="/2019/08/23/hexo-admin管理hexo文章/pasted-2.png" title="example">3.填入设置”用户名”、”密码”、”密文”<img src="/2019/08/23/hexo-admin管理hexo文章/pasted-3.png" title="example">4.将在下方生成的代码贴到博客根目录下的_config.yml文件中<img src="/2019/08/23/hexo-admin管理hexo文章/pasted-4.png" title="example"></li></ol><h3 id="5-设置deploy键调用生成和部署脚本"><a href="#5-设置deploy键调用生成和部署脚本" class="headerlink" title="5.设置deploy键调用生成和部署脚本"></a>5.设置deploy键调用生成和部署脚本</h3><p><strong>注</strong> :该配置针对linux服务器，windows的可能略有不同</p><ol><li><p>新建一个.sh文件(假设建在根目录下)，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch script-name.sh</span><br></pre></td></tr></table></figure></li><li><p>编辑脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x script-name.sh</span><br></pre></td></tr></table></figure></li><li><p>进入根目录下的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-admin authentification</span></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line"><span class="attr">  deployCommand:</span> <span class="string">'./hexo-generate.sh'</span></span><br></pre></td></tr></table></figure></li><li><p>重新生成并重启后即可一键生成和部署</p><img src="/2019/08/23/hexo-admin管理hexo文章/pasted-7.png" title="example"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/23/hello-world/"/>
      <url>/2019/08/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
